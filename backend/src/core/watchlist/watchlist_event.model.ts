/**
 * Watchlist Events Model - V2
 * 
 * Events generated by the monitoring layer:
 * - ACCUMULATION / DISTRIBUTION
 * - LARGE_TRANSFER
 * - BRIDGE_IN / BRIDGE_OUT
 * - ACTOR_ACTIVITY
 * 
 * These events feed into Alerts V2
 */
import mongoose, { Schema, Document, Types } from 'mongoose';

/**
 * Event types
 */
export type WatchlistEventType = 
  | 'ACCUMULATION'
  | 'DISTRIBUTION'
  | 'LARGE_TRANSFER'
  | 'BRIDGE_IN'
  | 'BRIDGE_OUT'
  | 'ACTOR_ACTIVITY';

/**
 * Severity levels
 */
export type WatchlistEventSeverity = 'LOW' | 'MEDIUM' | 'HIGH';

/**
 * WatchlistEvent Document Interface
 */
export interface IWatchlistEvent extends Document {
  _id: Types.ObjectId;
  watchlistItemId: Types.ObjectId;
  eventType: WatchlistEventType;
  severity: WatchlistEventSeverity;
  
  // Chain info (for cross-chain events)
  chain: string;
  chainFrom?: string;
  chainTo?: string;
  
  // Event details
  title: string;
  description: string;
  metadata: {
    txHash?: string;
    blockNumber?: number;
    value?: number;
    valueUsd?: number;
    percentChange?: number;
    [key: string]: any;
  };
  
  // Status
  acknowledged: boolean;
  acknowledgedAt?: Date;
  
  // Timestamps
  timestamp: Date;
  createdAt: Date;
}

/**
 * WatchlistEvent Schema
 */
const WatchlistEventSchema = new Schema<IWatchlistEvent>(
  {
    watchlistItemId: {
      type: Schema.Types.ObjectId,
      ref: 'WatchlistItem',
      required: true,
      index: true,
    },
    eventType: {
      type: String,
      enum: ['ACCUMULATION', 'DISTRIBUTION', 'LARGE_TRANSFER', 'BRIDGE_IN', 'BRIDGE_OUT', 'ACTOR_ACTIVITY'],
      required: true,
      index: true,
    },
    severity: {
      type: String,
      enum: ['LOW', 'MEDIUM', 'HIGH'],
      required: true,
      index: true,
    },
    chain: {
      type: String,
      required: true,
      default: 'ETH',
      index: true,
    },
    chainFrom: String,
    chainTo: String,
    title: {
      type: String,
      required: true,
    },
    description: String,
    metadata: {
      type: Schema.Types.Mixed,
      default: {},
    },
    acknowledged: {
      type: Boolean,
      default: false,
      index: true,
    },
    acknowledgedAt: Date,
    timestamp: {
      type: Date,
      required: true,
      default: Date.now,
      index: true,
    },
  },
  {
    timestamps: true,
    collection: 'watchlist_events',
  }
);

// Compound indexes for efficient queries
WatchlistEventSchema.index({ watchlistItemId: 1, timestamp: -1 });
WatchlistEventSchema.index({ severity: 1, timestamp: -1 });
WatchlistEventSchema.index({ eventType: 1, timestamp: -1 });
WatchlistEventSchema.index({ chain: 1, timestamp: -1 });

export const WatchlistEventModel = mongoose.model<IWatchlistEvent>(
  'WatchlistEvent',
  WatchlistEventSchema
);

// ============================================================================
// REPOSITORY FUNCTIONS
// ============================================================================

/**
 * Create a watchlist event
 */
export async function createWatchlistEvent(
  data: Partial<IWatchlistEvent>
): Promise<IWatchlistEvent> {
  const event = new WatchlistEventModel({
    ...data,
    timestamp: data.timestamp || new Date(),
  });
  await event.save();
  return event;
}

/**
 * Get events for a watchlist item
 */
export async function getEventsForItem(
  watchlistItemId: string,
  limit = 50
): Promise<IWatchlistEvent[]> {
  return WatchlistEventModel.find({ watchlistItemId })
    .sort({ timestamp: -1 })
    .limit(limit);
}

/**
 * Get all events with filters
 */
export async function getWatchlistEvents(filters: {
  chain?: string;
  severity?: string;
  eventType?: string;
  since?: Date;
  limit?: number;
}): Promise<IWatchlistEvent[]> {
  const query: any = {};
  
  if (filters.chain) query.chain = filters.chain;
  if (filters.severity) query.severity = filters.severity;
  if (filters.eventType) query.eventType = filters.eventType;
  if (filters.since) query.timestamp = { $gte: filters.since };
  
  return WatchlistEventModel.find(query)
    .sort({ timestamp: -1 })
    .limit(filters.limit || 100);
}

/**
 * Count events in last 24h for a watchlist item
 */
export async function countRecentEvents(watchlistItemId: string): Promise<number> {
  const since = new Date(Date.now() - 24 * 60 * 60 * 1000);
  return WatchlistEventModel.countDocuments({
    watchlistItemId,
    timestamp: { $gte: since },
  });
}

/**
 * Count items with events in last 24h
 */
export async function countItemsWithRecentEvents(): Promise<number> {
  const since = new Date(Date.now() - 24 * 60 * 60 * 1000);
  const result = await WatchlistEventModel.distinct('watchlistItemId', {
    timestamp: { $gte: since },
  });
  return result.length;
}

/**
 * Acknowledge event
 */
export async function acknowledgeEvent(eventId: string): Promise<boolean> {
  const result = await WatchlistEventModel.updateOne(
    { _id: eventId },
    { acknowledged: true, acknowledgedAt: new Date() }
  );
  return result.modifiedCount > 0;
}
