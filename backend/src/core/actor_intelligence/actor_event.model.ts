/**
 * Actor Events Model
 * 
 * Events generated by the Actor Pattern Detection Engine
 * These events:
 * - Feed into Watchlist
 * - Can create Alerts (MEDIUM/HIGH)
 * - Are displayed in UI
 */
import mongoose, { Schema, Document, Types } from 'mongoose';

/**
 * Actor Event Types
 */
export type ActorEventType = 
  | 'REPEAT_BRIDGE_PATTERN'
  | 'ROUTE_DOMINANCE'
  | 'LIQUIDITY_ESCALATION'
  | 'MULTI_CHAIN_PRESENCE'
  | 'STRATEGIC_TIMING'
  | 'NEW_STRATEGIC_ACTOR';

/**
 * Actor Event Severity
 */
export type ActorEventSeverity = 'LOW' | 'MEDIUM' | 'HIGH';

/**
 * Actor Event Document
 */
export interface IActorEvent extends Document {
  _id: Types.ObjectId;
  eventId: string;
  actorId: string;
  actorAddress: string;
  
  type: ActorEventType;
  severity: ActorEventSeverity;
  
  title: string;
  description: string;
  explanation: string;
  
  // Confidence for this specific event
  confidence: number;
  
  // Related data
  relatedMigrations: string[];
  relatedChains: string[];
  metadata: Record<string, any>;
  
  // Status
  acknowledged: boolean;
  acknowledgedAt?: Date;
  
  // Timestamps
  timestamp: Date;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Actor Event Schema
 */
const ActorEventSchema = new Schema<IActorEvent>(
  {
    eventId: {
      type: String,
      required: true,
      unique: true,
      index: true,
    },
    actorId: {
      type: String,
      required: true,
      index: true,
    },
    actorAddress: {
      type: String,
      required: true,
      index: true,
    },
    type: {
      type: String,
      required: true,
      enum: [
        'REPEAT_BRIDGE_PATTERN',
        'ROUTE_DOMINANCE',
        'LIQUIDITY_ESCALATION',
        'MULTI_CHAIN_PRESENCE',
        'STRATEGIC_TIMING',
        'NEW_STRATEGIC_ACTOR',
      ],
      index: true,
    },
    severity: {
      type: String,
      required: true,
      enum: ['LOW', 'MEDIUM', 'HIGH'],
      index: true,
    },
    title: {
      type: String,
      required: true,
    },
    description: String,
    explanation: {
      type: String,
      required: true,
    },
    confidence: {
      type: Number,
      required: true,
      min: 0,
      max: 1,
    },
    relatedMigrations: [{
      type: String,
    }],
    relatedChains: [{
      type: String,
    }],
    metadata: {
      type: Schema.Types.Mixed,
      default: {},
    },
    acknowledged: {
      type: Boolean,
      default: false,
      index: true,
    },
    acknowledgedAt: Date,
    timestamp: {
      type: Date,
      required: true,
      default: Date.now,
      index: true,
    },
  },
  {
    timestamps: true,
    collection: 'actor_events',
  }
);

// Compound indexes
ActorEventSchema.index({ actorId: 1, timestamp: -1 });
ActorEventSchema.index({ type: 1, timestamp: -1 });
ActorEventSchema.index({ severity: 1, timestamp: -1 });

export const ActorEventModel = mongoose.models.ActorEvent as mongoose.Model<IActorEvent> ||
  mongoose.model<IActorEvent>('ActorEvent', ActorEventSchema);

// ============================================================================
// REPOSITORY FUNCTIONS
// ============================================================================

/**
 * Create actor event
 */
export async function createActorEvent(
  data: Partial<IActorEvent>
): Promise<IActorEvent> {
  const event = new ActorEventModel({
    ...data,
    timestamp: data.timestamp || new Date(),
  });
  await event.save();
  return event;
}

/**
 * Get recent actor events
 */
export async function getActorEvents(filters?: {
  actorId?: string;
  type?: ActorEventType;
  severity?: ActorEventSeverity;
  since?: Date;
  limit?: number;
}): Promise<IActorEvent[]> {
  const query: any = {};
  
  if (filters?.actorId) query.actorId = filters.actorId;
  if (filters?.type) query.type = filters.type;
  if (filters?.severity) query.severity = filters.severity;
  if (filters?.since) query.timestamp = { $gte: filters.since };
  
  return ActorEventModel.find(query)
    .sort({ timestamp: -1 })
    .limit(filters?.limit || 50);
}

/**
 * Check if similar event exists recently
 */
export async function eventExistsRecently(
  actorId: string,
  type: ActorEventType,
  windowHours = 24
): Promise<boolean> {
  const since = new Date(Date.now() - windowHours * 60 * 60 * 1000);
  
  const existing = await ActorEventModel.findOne({
    actorId,
    type,
    timestamp: { $gte: since },
  });
  
  return !!existing;
}

/**
 * Acknowledge event
 */
export async function acknowledgeActorEvent(eventId: string): Promise<boolean> {
  const result = await ActorEventModel.updateOne(
    { eventId },
    { acknowledged: true, acknowledgedAt: new Date() }
  );
  return result.modifiedCount > 0;
}
